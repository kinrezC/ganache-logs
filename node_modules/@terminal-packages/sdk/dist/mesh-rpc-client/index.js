"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const terminal_base_provider_1 = require("../web3/providers/base/terminal-base-provider");
const enums_1 = require("../web3/providers/enums");
const mesh_rpc_client_1 = require("@0x/mesh-rpc-client");
const lodash_1 = __importDefault(require("lodash"));
// @ts-ignore
class TerminalWSClientProvider extends mesh_rpc_client_1.WSClient {
    constructor(_options) {
        super(_options.wsOptions.url, _options.wsOptions.wsOpts);
        this._originalWsProvider = this._wsProvider;
        this._wsProvider = lodash_1.default.cloneDeep(this._wsProvider);
        this.terminalBaseProviderInstance = new terminal_base_provider_1.TerminalBaseProvider(enums_1.ProviderType.websocketProvider, true, {
            apiKey: _options.apiKey,
            environment: _options.environment,
            projectId: _options.projectId,
            source: enums_1.SourceType.ZeroXMesh,
            web3Version: enums_1.Web3Versions.one,
        });
        this.overrideSendPayload();
    }
    /**
     * overrideSendPayload will ensure that we can intercept the JSON RPC call
     * it should enable TerminalBaseProvider to work as intended and call the real WS provider
     */
    overrideSendPayload() {
        // @ts-ignore
        this.terminalBaseProviderInstance._provider = this._originalWsProvider;
        this._wsProvider.sendPayload = (payload) => {
            return new Promise((resolve, reject) => {
                this.terminalBaseProviderInstance.sendAsync(payload, (err, result) => {
                    if (!err) {
                        return resolve(result);
                    }
                    reject(err);
                });
            });
        };
    }
}
exports.TerminalWSClientProvider = TerminalWSClientProvider;
