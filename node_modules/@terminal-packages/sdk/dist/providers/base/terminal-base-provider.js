"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_service_1 = require("../../shared/api/api-service");
const environment_types_1 = require("../../shared/enums/environment-types");
const log_level_1 = require("../../shared/enums/log-level");
const utils_1 = require("../../shared/utils");
const enums_1 = require("../enums");
const source_types_1 = require("../enums/source-types");
class TerminalBaseProvider {
    constructor(_providerType, _isCustomProvider, _baseOptions) {
        this._providerType = _providerType;
        this._isCustomProvider = _isCustomProvider;
        this._baseOptions = _baseOptions;
        this.connected = false;
        this.UNKNOWN = 'unknown';
        if (!this._baseOptions.apiKey) {
            throw new Error('You must supply an API key to the `Provider`');
        }
        if (!this._baseOptions.source) {
            throw new Error('You must supply a source to the `Provider`');
        }
        if (!this._baseOptions.projectId) {
            throw new Error('You must supply a projectId to the `Provider`');
        }
        if (this._baseOptions.environment &&
            !environment_types_1.EnvironmentTypes[this._baseOptions.environment]) {
            throw new Error('You must supply a valid environment type of `dev`, `staging` or `live`. Will default to live if no environment is passed in');
        }
        this.web3Version = this._baseOptions.web3Version || enums_1.Web3Versions.two;
        this._baseProviderOptions = {
            source: this._baseOptions.source,
            apiKey: this._baseOptions.apiKey,
            projectId: this._baseOptions.projectId,
            logLevel: this._baseOptions.logLevel === undefined
                ? log_level_1.LogLevel.Error
                : this._baseOptions.logLevel,
            environment: this._baseOptions.environment || environment_types_1.EnvironmentTypes.live,
            web3Version: this.web3Version,
        };
        this._apiService = new api_service_1.ApiService(this._baseProviderOptions.apiKey, this._baseProviderOptions.environment);
        // DEV NOTE: turning this feature off until is ready in all envs
        // this.sendAck();
    }
    /**
     * Send async jsonrpc method interceptor (backwards compatibility)
     * @param payload The jsonrpc payload
     * @param callback The callback
     */
    sendAsync(payload, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = payload;
            let errorMessage;
            const responseTimeMs = [];
            try {
                // if `response` is array then its a bulk send
                if (Array.isArray(response)) {
                    const results = [];
                    for (let g = 0; g < response.length; g++) {
                        const start = new Date().getTime();
                        const result = yield this.send(response[g].method, response[g].params, true);
                        const end = new Date().getTime();
                        response[g].result = result;
                        results.push(result);
                        responseTimeMs.push(end - start);
                    }
                    callback(null, results);
                }
                else {
                    let start;
                    let result;
                    if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                        start = new Date().getTime();
                        result = yield this._provider.send(response.method, response.params);
                        response.result = result;
                    }
                    else if (this.web3Version === enums_1.Web3Versions.one &&
                        this._isCustomProvider) {
                        start = new Date().getTime();
                        result = yield this.send(response, [], true);
                        response.result = result.result;
                    }
                    else {
                        start = new Date().getTime();
                        result = yield this.send(response.method, response.params, true);
                        response.result = result;
                    }
                    const end = new Date().getTime();
                    responseTimeMs.push(end - start);
                    if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                        // if its MM then we need to go just pass in the result as on the
                        // 0.2.x version it has a different interface
                        if (response.id !== result.id) {
                            result.id = response.id;
                        }
                        // bug with MM provider they do not return jsonrpc version
                        result.jsonrpc = '2.0';
                        callback(null, result);
                    }
                    else {
                        callback(null, response);
                    }
                }
            }
            catch (error) {
                // handle MM error stack as it provides much better message errors
                if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                    errorMessage = this.buildUpMetaMaskErrorMessage(error);
                }
                else if (error.message) {
                    errorMessage = error.message;
                }
                else {
                    errorMessage = error;
                }
                callback(error, null);
            }
            // save the log last so the `callback` can be set so web3 can carry on
            try {
                if (!errorMessage) {
                    // if `response` is array then its a bulk send
                    if (Array.isArray(response)) {
                        for (let l = 0; l < response.length; l++) {
                            if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                                this.saveToLogs(response[l], response[l].result.result, responseTimeMs[l]);
                            }
                            else {
                                this.saveToLogs(response[l], response[l].result, responseTimeMs[l]);
                            }
                        }
                    }
                    else {
                        if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                            // the result itself is in `.result.result` as again its using a own 0.2.x interface
                            this.saveToLogs(response, response.result.result, responseTimeMs[0]);
                        }
                        else {
                            this.saveToLogs(response, response.result, responseTimeMs[0]);
                        }
                    }
                }
                else {
                    // if its a batch request using `0.2.x` web3 instance
                    if (Array.isArray(response)) {
                        for (let l = 0; l < response.length; l++) {
                            this.saveToLogs(response[l], errorMessage, responseTimeMs[l], true);
                        }
                    }
                    else {
                        this.saveToLogs(response, errorMessage, responseTimeMs[0], true);
                    }
                }
            }
            catch (error) {
                // tslint:disable-next-line: no-console
                console.error(
                // tslint:disable-next-line: max-line-length
                `Could not save log, something in your terminal setup is incorrect or the log server is currently down ${error}`);
            }
        });
    }
    /**
     * Send jsonrpc method interceptor
     * @param method The jsonrpc method (in some old cases it may send the `ISendAsyncPayload` interface)
     * @param parameters The parameters
     * @param _fromSendAsync This tells us if send async did the call which means `saveToLogs` has already been called.
     *                       web3 have different behaviour between 1.0 and 2.0 so have to handle some edge cases here.
     */
    send(methodOrPayload, parameters = [], _fromSendAsync = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._provider) {
                throw new Error('Provider is not set');
            }
            // web3 1.x takes in the whole payload so we need to handle that
            // and make sure we send the entire payload BUT only if a custom provider
            // is defined as if not we use our provider which is 2.x compatible
            if (this.web3Version === enums_1.Web3Versions.one &&
                this._isCustomProvider &&
                this._baseProviderOptions.source !== source_types_1.SourceType.MetaMask) {
                if (typeof methodOrPayload !== 'object') {
                    throw new Error('Payload should be a object');
                }
                methodOrPayload = methodOrPayload;
                methodOrPayload.params = methodOrPayload.params || [];
                if (typeof methodOrPayload.method !== 'string') {
                    throw new Error('Method is not a valid string');
                }
                // if they are using `web3-provider-engine` due to that behaviouring
                // differently it needs to go into `sendAsync` and wait for the callback
                if (this.isUsingWeb3ProviderEngine()) {
                    return yield new Promise((resolve, reject) => {
                        // @ts-ignore
                        this._provider.sendAsync(methodOrPayload, (error, result) => {
                            if (error) {
                                reject(error);
                            }
                            else {
                                resolve(result);
                            }
                        });
                    });
                }
                else {
                    // only cover ones which do not fall in the criteria above
                    switch (this._baseProviderOptions.source) {
                        case source_types_1.SourceType.WalletLink:
                        case source_types_1.SourceType.Alchemy:
                            const result = yield this._provider.send(methodOrPayload.method, methodOrPayload.params);
                            return { result };
                        default:
                            // @ts-ignore
                            return yield this._provider.send(methodOrPayload);
                    }
                }
            }
            else {
                // handle 0.20.x cases with metamask where they hit send straight away
                // without going through `sendAsync`
                // this is for bespoke stuff like `sendBulk` but we need to handle it
                if (typeof methodOrPayload === 'object' &&
                    typeof methodOrPayload.method === 'string') {
                    parameters = methodOrPayload.params || [];
                    methodOrPayload = methodOrPayload.method;
                }
                if (!methodOrPayload || typeof methodOrPayload !== 'string') {
                    throw new Error('Method is not a valid string');
                }
                if (!(parameters instanceof Array)) {
                    throw new Error('Params is not a valid array');
                }
                // use the provider which set in constructor to call the node
                return yield this._provider.send(methodOrPayload, parameters);
            }
        });
    }
    /**
     * Send batch will just send 1 at the time for now
     * @param methods The method
     * @param moduleInstance The module instances
     */
    sendBatch(methods, moduleInstance) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            const result = yield this._provider.sendBatch(methods, moduleInstance);
            const payloads = [];
            for (let i = 0; i < methods.length; i++) {
                const rpcMethodResponse = result[i];
                payloads.push({
                    payload: {
                        id: rpcMethodResponse.id,
                        jsonrpc: rpcMethodResponse.jsonrpc,
                        method: methods[i].rpcMethod,
                        params: methods[i].parameters,
                        result: rpcMethodResponse.result || rpcMethodResponse.error,
                    },
                    isError: rpcMethodResponse.error !== undefined,
                });
            }
            this.saveBulkToLogs(payloads);
            return result;
        });
    }
    /**
     * Get chain id
     * @param provider The provider
     */
    getChainId(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._chainId) {
                return this._chainId;
            }
            try {
                let netVersion;
                if (this.web3Version === enums_1.Web3Versions.one &&
                    this._isCustomProvider &&
                    this._baseProviderOptions.source !== source_types_1.SourceType.MetaMask) {
                    const netVersionJsonRpcPayload = {
                        id: '0',
                        jsonrpc: '2.0',
                        method: 'net_version',
                        params: [],
                    };
                    // if they are using `web3-provider-engine` due to that behaviouring
                    // differently it needs to go into `sendAsync` and wait for the callback
                    if (this.isUsingWeb3ProviderEngine()) {
                        netVersion = yield new Promise((resolve, reject) => {
                            // @ts-ignore
                            this._provider.sendAsync(netVersionJsonRpcPayload, (error, result) => {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve(result);
                                }
                            });
                        });
                    }
                    else {
                        netVersion = yield provider.send(netVersionJsonRpcPayload);
                    }
                }
                else {
                    netVersion = yield provider.send('net_version', []);
                }
                if (netVersion) {
                    if (typeof netVersion === 'string') {
                        return netVersion;
                    }
                    else {
                        return netVersion.result;
                    }
                }
                return this.UNKNOWN;
            }
            catch (error) {
                // mute error and state unknown
            }
            return this.UNKNOWN;
        });
    }
    /**
     * Save bulk to logs
     * @param bulkPayloads The bulk payload
     */
    saveBulkToLogs(bulkPayloads) {
        for (let i = 0; i < bulkPayloads.length; i++) {
            const info = bulkPayloads[i];
            this.saveToLogs(info.payload, info.payload.result, undefined, info.isError);
        }
    }
    /**
     * Save to logs
     * @param payload The payload
     * @param result The result
     * @param responseTimeMs The response time
     * @param isError If its a error
     */
    saveToLogs(payload, result, responseTimeMs, isError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(payload.params)) {
                payload.params = [payload.params];
            }
            if (Array.isArray(payload.params)) {
                for (let i = 0; i < payload.params.length; i++) {
                    if (typeof payload.params[i] === 'object') {
                        payload.params[i] = JSON.stringify(payload.params[i]);
                    }
                }
            }
            let chainId = this._chainId;
            let fromAddress;
            if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                chainId = this.getMetaMaskChainId();
                const _window = utils_1.Utils.getWindow();
                if (_window && _window.ethereum) {
                    // get the MM accounts
                    const accounts = yield _window.ethereum.enable();
                    if (accounts.length > 0) {
                        fromAddress = utils_1.Utils.toChecksumAddress(accounts[0]);
                    }
                }
            }
            let headers = [];
            if (this.extraProviderLoggingOptions &&
                this.extraProviderLoggingOptions.headers) {
                headers = this.extraProviderLoggingOptions.headers;
            }
            const logRequest = {
                id: payload.id,
                jsonrpc: payload.jsonrpc,
                nodeUrl: this.getHost(),
                method: payload.method,
                parameters: payload.params || [],
                result: this.parseJsonRPCResult(result),
                source: this._baseProviderOptions.source,
                isError,
                responseTimeMs,
                chainId,
                headers: JSON.stringify(headers),
                projectId: this._baseProviderOptions.projectId,
                fromAddress,
            };
            yield this._apiService.saveToLogs(logRequest);
        });
    }
    /**
     * Parse the jsonrpc result
     * @param result The jsonrpc result
     */
    parseJsonRPCResult(result) {
        if (!result) {
            return null;
        }
        if (typeof result === 'string') {
            return result;
        }
        if (typeof result === 'object') {
            const deepResultClone = utils_1.Utils.deepClone(result);
            return JSON.stringify(deepResultClone);
        }
        return result.toString();
    }
    /**
     * Set the chain id
     */
    setChainId(provider, 
    // tslint:disable-next-line: no-unnecessary-initializer
    web3Version = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            this._chainId = yield this.getChainId(provider);
            // if its web3 1 kill this provider as we had to used
            // web3 2.0 so we can get chainId
            if (web3Version === enums_1.Web3Versions.one && provider.connection) {
                provider.connection.close();
            }
        });
    }
    /**
     * Get websocket provider host
     */
    getWebsocketProviderHost() {
        const websocketProvider = this._provider;
        // check for normal providers if the host is set in context
        // this would be on none custom providers
        if (this.host) {
            return this.host;
        }
        // check if the host exists first
        // do this everytime to make sure we keep the nodeUrl
        // to the latest
        if (websocketProvider.host) {
            return websocketProvider.host;
        }
        if (this.web3Version === enums_1.Web3Versions.one &&
            // @ts-ignore
            websocketProvider.connection &&
            // @ts-ignore
            websocketProvider.connection.url) {
            // @ts-ignore
            return websocketProvider.connection.url;
        }
        return this.UNKNOWN;
    }
    /**
     * Send async ack to register integration in the backend
     */
    sendAck() {
        return __awaiter(this, void 0, void 0, function* () {
            const ackRequest = {
                source: this._baseOptions.source,
                projectId: this._baseOptions.projectId,
                nodeUrl: this.host,
                sourceCategory: Object(enums_1.SourceCategory)[this._baseOptions.source] || 'Unknown',
            };
            yield this._apiService.sendAck(ackRequest);
        });
    }
    /**
     * Get the host, we need to do this everytime so we can fetch the latest
     * nodeUrl on some providers who change that constantly
     */
    getHost() {
        let host = this.UNKNOWN;
        switch (this._providerType) {
            case enums_1.ProviderType.httpProvider:
                host = this.getHttpProviderHost();
                break;
            case enums_1.ProviderType.websocketProvider:
                host = this.getWebsocketProviderHost();
                break;
        }
        // extra checking on host just incase something messed with it
        if (!host || typeof host !== 'string' || host.length === 0) {
            host = this.UNKNOWN;
        }
        return host;
    }
    /**
     * Get http provider host
     */
    getHttpProviderHost() {
        const httpProvider = this._provider;
        // check for normal providers if the host is set in context
        // this would be on none custom providers
        if (this.host) {
            return this.host;
        }
        // check if its MM
        if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
            // MetaMask do not expose node url so just return unknown
            return this.UNKNOWN;
        }
        // check if the host exists first
        // do this everytime to make sure we keep the nodeUrl
        // to the latest
        if (httpProvider.host) {
            return httpProvider.host;
        }
        // check if they're using MM `web3-provider-engine` like legder do and more providers
        // @ts-ignore
        if (Array.isArray(httpProvider._providers)) {
            const providerDetails = 
            // @ts-ignore
            httpProvider._providers[
            // @ts-ignore
            httpProvider._providers.length - 1];
            if (providerDetails &&
                typeof providerDetails === 'object' &&
                typeof providerDetails.rpcUrl === 'string' &&
                providerDetails.rpcUrl.length > 0) {
                return providerDetails.rpcUrl;
            }
        }
        return this.UNKNOWN;
    }
    /**
     * Get metamask chain id
     */
    getMetaMaskChainId() {
        if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
            const _window = utils_1.Utils.getWindow();
            if (_window && _window.ethereum && _window.ethereum.networkVersion) {
                return _window.ethereum.networkVersion;
            }
        }
        return 'unknown';
    }
    /**
     * Build up metamask error message for the logs
     * @param error The error
     */
    buildUpMetaMaskErrorMessage(error) {
        if (!error) {
            return 'MetaMask error occurred but did not emit any useful errors';
        }
        if (typeof error === 'string') {
            return error;
        }
        return `code: ${error.code}, message: ${error.message}, stack: ${error.stack}`;
    }
    /**
     * Return true if using web3 provider engine
     */
    isUsingWeb3ProviderEngine() {
        return (this._baseOptions.source === source_types_1.SourceType.Web3ProviderEngine ||
            // @ts-ignore
            this._provider._running !== undefined ||
            // @ts-ignore
            Array.isArray(this._provider._providers) ||
            this._provider.constructor.name === 'Web3ProviderEngine' ||
            (this._provider.engine !== undefined &&
                this._provider.engine.addProvider !== undefined) ||
            (this._provider.rpcEngine &&
                this._provider.rpcEngine._middleware));
    }
}
exports.TerminalBaseProvider = TerminalBaseProvider;
