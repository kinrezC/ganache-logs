"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_providers_1 = require("web3-providers");
// @ts-ignore
const web3_providers_ws_1 = __importDefault(require("web3-providers-ws"));
const json_rpc_mapper_1 = __importDefault(require("../../mappers/json-rpc-mapper"));
const terminal_base_provider_1 = require("../base/terminal-base-provider");
const enums_1 = require("../enums");
class TerminalWebsocketProvider extends terminal_base_provider_1.TerminalBaseProvider {
    constructor(options) {
        super(enums_1.ProviderType.websocketProvider, options
            .customWebsocketProvider !== undefined, options);
        this.connection = {
            close: () => {
                // @ts-ignore
                this.websocketProvider.connection.close();
            },
        };
        let _host;
        // @ts-ignore
        if (options.customWebsocketProvider) {
            const customProviderOptions = options;
            this._provider = customProviderOptions.customWebsocketProvider;
            _host = this.getWebsocketProviderHost();
        }
        else {
            const basicProviderOptions = options;
            this.host = basicProviderOptions.host;
            if (!this.host || this.host.length === 0) {
                throw new Error('The host is not defined or is set as a empty string');
            }
            if (this.web3Version === enums_1.Web3Versions.two) {
                this._provider = new web3_providers_1.WebsocketProvider(this.host, basicProviderOptions.options);
            }
            else {
                this._provider = new web3_providers_ws_1.default(this.host, basicProviderOptions.options);
                // register error as web3 1.0 by default doesnt do this
                this.on('error', () => { });
            }
            _host = this.host;
            if (basicProviderOptions.options) {
                this.extraProviderLoggingOptions = {
                    headers: basicProviderOptions.options.headers,
                };
            }
        }
        if (this.web3Version === enums_1.Web3Versions.two) {
            this.setChainId(this._provider, enums_1.Web3Versions.two);
        }
        else {
            // if the host is not exposed by the custom provider then we can not
            // show them the chainId
            if (_host && _host !== this.UNKNOWN) {
                // use the websocket from 2.0 here as the 1.0 does not work to fetch chainId
                this.setChainId(new web3_providers_1.WebsocketProvider(_host), enums_1.Web3Versions.one);
            }
        }
    }
    /**
     * Send jsonrpc method interceptor
     * @param method The jsonrpc method (in some old cases it may send the `ISendAsyncPayload` interface)
     * @param parameters The parameters
     * @param _fromSendAsync This tells us if send async did the call which means `saveToLogs` has already been called.
     *                       web3 have different behaviour between 1.0 and 2.0 so have to handle some edge cases here.
     */
    send(method, parameters = [], _fromSendAsync = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // handle 0.20.x cases
            // without going through `sendAsync`
            // this is for bespoke stuff like `sendBulk` but we need to handle it
            if (typeof method === 'object' && typeof method.method === 'string') {
                parameters = method.params || [];
                method = method.method;
            }
            if (!method || typeof method !== 'string') {
                throw new Error('Method is not a valid string');
            }
            if (!(parameters instanceof Array)) {
                throw new Error('Params is not a valid array');
            }
            if (!this._provider) {
                throw new Error('Provider is not set');
            }
            const payload = json_rpc_mapper_1.default.toPayload(method, parameters);
            if (this.web3Version === enums_1.Web3Versions.two) {
                const start = new Date().getTime();
                const response = yield this.sendPayload(payload);
                const end = new Date().getTime();
                if (!_fromSendAsync) {
                    this.saveToLogs(payload, response.result, end - start);
                }
                return response.result;
            }
            else {
                const start = new Date().getTime();
                const response = yield new Promise((resolve) => {
                    this.websocketProvider.send(
                    // @ts-ignore
                    payload, 
                    // @ts-ignore
                    (error, result) => {
                        resolve(result);
                    });
                });
                const end = new Date().getTime();
                if (!_fromSendAsync) {
                    this.saveToLogs(payload, response.result, end - start);
                }
                return response.result;
            }
        });
    }
    /**
     * If it supports subscriptions
     */
    supportsSubscriptions() {
        return this.websocketProvider.supportsSubscriptions();
    }
    /**
     * Register event listeners
     */
    registerEventListeners() {
        this.websocketProvider.registerEventListeners();
    }
    /**
     * Send payload
     * @param payload The payload
     */
    sendPayload(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            return yield this.websocketProvider.sendPayload(payload);
        });
    }
    /**
     * If the websocket connecting is connected
     */
    isConnecting() {
        return this.websocketProvider.isConnecting();
    }
    /**
     * Subscribe
     * @param subscribeMethod The subscribe method
     * @param subscriptionMethod The subscription method
     * @param parameters The parameters
     */
    subscribe(subscribeMethod, subscriptionMethod, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.websocketProvider.subscribe(subscribeMethod, subscriptionMethod, parameters);
        });
    }
    /**
     * On provider event
     * @param event The subscription id
     * @param callback The callback
     */
    on(event, callback) {
        // @ts-ignore
        this.websocketProvider.on(event, (result) => {
            if (this.web3Version === enums_1.Web3Versions.two) {
                const subscription = this.websocketProvider.subscriptions[event];
                this.saveToLogs(json_rpc_mapper_1.default.toPayload(subscription.subscribeMethod, subscription.parameters), result.result, undefined, event === 'error');
            }
            else {
                let shouldSaveLogs = true;
                let parsedResult = result || null;
                if (parsedResult &&
                    parsedResult.params &&
                    parsedResult.result !== undefined) {
                    parsedResult = result.params.result;
                }
                // handle web3 1.0 websocket issues with firing over and over again
                // with the same result
                if (this._lastNodeSavedResult) {
                    if (this._lastNodeSavedResult.nodeResult ===
                        this.parseJsonRPCResult(parsedResult)) {
                        // If the last node saved result is higher or equal to 200 ago then save log
                        shouldSaveLogs =
                            new Date().getTime() >=
                                this._lastNodeSavedResult.firedAtTimestamp + 200;
                    }
                }
                if (shouldSaveLogs) {
                    this._lastNodeSavedResult = {
                        nodeResult: this.parseJsonRPCResult(parsedResult),
                        firedAtTimestamp: new Date().getTime(),
                    };
                    this.saveToLogs(json_rpc_mapper_1.default.toPayload(result.method, []), parsedResult, undefined, event === 'error');
                }
            }
            callback(result);
        });
    }
    /**
     * Unsubscribe from a method
     * @param subscriptionId The subscription id
     * @param unsubscribeMethod The unsubscribe method
     */
    unsubscribe(subscriptionId, unsubscribeMethod) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.websocketProvider.unsubscribe(subscriptionId, unsubscribeMethod);
        });
    }
    /**
     * Clear subscriptions
     * @param unsubscribeMethod The unsubscribe method
     */
    clearSubscriptions(unsubscribeMethod) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.websocketProvider.clearSubscriptions(unsubscribeMethod);
        });
    }
    /**
     * Remove listener
     * @param type The listener type
     * @param callback The callback
     */
    removeListener(type, callback) {
        this.websocketProvider.removeListener(type, callback);
    }
    /**
     * Remove all listeners
     * @param type The listener type
     */
    removeAllListeners(type) {
        this.websocketProvider.removeAllListeners(type);
    }
    /**
     * Reset the websocket
     */
    reset() {
        this.websocketProvider.reset();
    }
    /**
     * Reconnect to the websocket connection
     */
    reconnect() {
        this.websocketProvider.reconnect();
    }
    /**
     * Disconnect from the websocket connection
     * @param code The code
     * @param reason The reason
     */
    disconnect(code, reason) {
        this.websocketProvider.disconnect(code, reason);
    }
    /**
     * Gets the provider and makes sure it comes back as `WebsocketProvider` type
     */
    get websocketProvider() {
        if (!this._provider) {
            throw new Error('Provider is not set');
        }
        return this._provider;
    }
}
exports.TerminalWebsocketProvider = TerminalWebsocketProvider;
