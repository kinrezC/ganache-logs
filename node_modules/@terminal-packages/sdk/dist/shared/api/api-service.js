"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const v1_1 = __importDefault(require("uuid/v1"));
const enums_1 = require("../enums");
const environment_types_1 = require("../enums/environment-types");
const utils_1 = require("../utils");
const enums_2 = require("./enums");
class ApiService {
    constructor(_apiKey, _environment) {
        this._apiKey = _apiKey;
        this._environment = _environment;
        this._sessionId = v1_1.default();
    }
    /**
     * Save the json rpc log
     * @param saveLogRequest The save log request
     */
    saveJsonRpcLog(saveLogRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            // Any jsonrpc calls which have personal signature data should NEVER
            // be exposed to our server or in our database.
            // We still want to log the request but we should mask the result
            // and make it unreadable
            if (saveLogRequest.result) {
                switch (saveLogRequest.method) {
                    case enums_1.JsonRpcMethods.eth_signTransaction:
                    case enums_1.JsonRpcMethods.personal_sign:
                    case enums_1.JsonRpcMethods.eth_sign:
                    case enums_1.JsonRpcMethods.eth_signTypedData:
                        saveLogRequest.result = utils_1.Utils.makeStringUnreadable(saveLogRequest.result);
                        break;
                    case enums_1.JsonRpcMethods.eth_sendRawTransaction:
                        saveLogRequest.parameters[0] = utils_1.Utils.makeStringUnreadable(saveLogRequest.parameters[0]);
                }
            }
            const saveFullLogRequest = Object.assign(Object.assign({}, saveLogRequest), { sessionId: this._sessionId });
            yield cross_fetch_1.default(`${this.environmentUrl}logs/networks`, {
                method: enums_2.HttpVerb.POST,
                mode: 'cors',
                cache: 'no-cache',
                headers: {
                    // tslint:disable-next-line: object-literal-key-quotes
                    ApiKey: this._apiKey,
                    'Content-Type': enums_2.ContentTypes.applicationJson,
                    'x-request-id': v1_1.default(),
                },
                body: JSON.stringify(saveFullLogRequest),
            });
        });
    }
    /**
     * Save to logs apollo endpoint
     * @param saveApolloLogRequest The apollo log request
     */
    saveApolloLog(saveApolloLogRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            yield cross_fetch_1.default(`${this.environmentUrl}logs/graphql-log`, {
                method: enums_2.HttpVerb.POST,
                mode: 'cors',
                cache: 'no-cache',
                headers: {
                    // tslint:disable-next-line: object-literal-key-quotes
                    ApiKey: this._apiKey,
                    'Content-Type': enums_2.ContentTypes.applicationJson,
                    'x-request-id': v1_1.default(),
                },
                body: JSON.stringify(saveApolloLogRequest),
            });
        });
    }
    /**
     * Registers a new provider on the integrations page
     * @param providerAck The providerInfo
     */
    sendAck(providerAck) {
        return __awaiter(this, void 0, void 0, function* () {
            yield cross_fetch_1.default(`${this.environmentUrl}logs/integrations/ack`, {
                method: enums_2.HttpVerb.POST,
                mode: 'cors',
                cache: 'no-cache',
                headers: {
                    // tslint:disable-next-line: object-literal-key-quotes
                    ApiKey: this._apiKey,
                    'Content-Type': enums_2.ContentTypes.applicationJson,
                    'x-request-id': v1_1.default(),
                },
                body: JSON.stringify(providerAck),
            });
        });
    }
    /**
     * Save ipfs log
     * @param request The ipfs log request
     */
    saveIpfsRequestLog(request) {
        return __awaiter(this, void 0, void 0, function* () {
            yield cross_fetch_1.default(`${this.environmentUrl}logs/ipfs`, {
                method: enums_2.HttpVerb.POST,
                mode: 'cors',
                cache: 'no-cache',
                headers: {
                    // tslint:disable-next-line: object-literal-key-quotes
                    ApiKey: this._apiKey,
                    'Content-Type': enums_2.ContentTypes.applicationJson,
                    'x-request-id': v1_1.default(),
                },
                body: JSON.stringify(request),
            });
        });
    }
    /**
     * Get request
     * @param url The url
     */
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield cross_fetch_1.default(url, {
                method: enums_2.HttpVerb.GET,
                mode: 'cors',
                cache: 'no-cache',
                headers: {
                    'x-request-id': v1_1.default(),
                },
            });
            if (this.responseContentTypeApplicationJson(response)) {
                return yield this.parseJsonResult(response);
            }
            else {
                return yield this.parseTextResult(response);
            }
        });
    }
    /**
     * Post request
     * @param url The url
     * @param body The body
     * @param options The post options
     */
    post(url, body, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let headers = {};
            if (options) {
                if (options.header) {
                    headers = options.header;
                }
                if (options.contentType) {
                    headers['Content-Type'] = options.contentType;
                }
                if (options.includeApiKeyInHeader !== undefined &&
                    options.includeApiKeyInHeader === true) {
                    headers.ApiKey = this._apiKey;
                    headers['x-request-id'] = v1_1.default();
                }
            }
            const response = yield cross_fetch_1.default(url, {
                method: enums_2.HttpVerb.POST,
                mode: 'cors',
                cache: 'no-cache',
                headers,
                body,
            });
            if (this.responseContentTypeApplicationJson(response)) {
                return yield this.parseJsonResult(response);
            }
            else {
                return yield this.parseTextResult(response);
            }
        });
    }
    /**
     * Check if the response content type is applicationJson
     * @param response The fetch response
     */
    responseContentTypeApplicationJson(response) {
        const responseContentType = response.headers.get('content-type');
        if (responseContentType &&
            responseContentType.indexOf(enums_2.ContentTypes.applicationJson) !== -1) {
            return true;
        }
        return false;
    }
    /**
     * Parse json result or throw json result
     * @param response The fetch response
     */
    parseJsonResult(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const jsonResult = (yield response.json());
            if (response.ok) {
                return jsonResult;
            }
            else {
                throw jsonResult;
            }
        });
    }
    /**
     * Parse text result or throw text result
     * @param response The fetch response
     */
    parseTextResult(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const textResult = yield response.text();
            if (response.ok) {
                return textResult;
            }
            else {
                throw textResult;
            }
        });
    }
    /**
     * get the environment url
     */
    get environmentUrl() {
        switch (this._environment) {
            case environment_types_1.EnvironmentTypes.dev:
                return 'https://dev.terminal.co/';
            case environment_types_1.EnvironmentTypes.staging:
                return 'https://stg.terminal.co/';
            default:
                return 'https://terminal.co/';
        }
    }
}
exports.ApiService = ApiService;
